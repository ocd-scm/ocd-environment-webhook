#!/bin/bash

# Created by argbash-init v2.7.1
# ARG_OPTIONAL_SINGLE([insecure-no-tls-verify],[],[optional skip TLS verify needed for minishift],[false])
# ARG_OPTIONAL_SINGLE([webhook-secret],[],[optional webhook secret will otherwise be generated],[])
# ARG_OPTIONAL_SINGLE([release-hook],[],[optional match a release event rather than a push event],[false])
# ARG_POSITIONAL_SINGLE([oc-server],[mandatory server e.g. 192.168.99.100:8443])
# ARG_POSITIONAL_SINGLE([oc-user],[mandatory username e.g. admin])
# ARG_POSITIONAL_SINGLE([oc-passwd],[mandatory password e.g. admin])
# ARG_POSITIONAL_SINGLE([tiller-namespace],[mandatory namespace where tiller is running])
# ARG_POSITIONAL_SINGLE([namespace],[mandatory namespace to install into])
# ARG_POSITIONAL_SINGLE([git-url],[mandatory url of the enviroment code to checkout e.g. https://github.com/ocd-scm/ocd-demo-env-build.git ])
# ARG_POSITIONAL_SINGLE([git-name],[mandatory name of the repo that fires the webhook used to sanity check the webhook payload is from the correct repo e.g. ocd-scm/ocd-demo-env-build])
# ARG_POSITIONAL_SINGLE([webhook-ref-regex],[mandatory the regex to match the git ref e.g. "refs/heads/master" to match a branch or ".*-RELEASE" to match a release tag])
# ARG_POSITIONAL_SINGLE([env],[mandatory the env prefix to make the installed chart unique e.g. live])
# ARG_DEFAULTS_POS()
# ARG_HELP([Welcome to the ocd-envrionment-webhook installer. It runs heml to install into the current project. It needs some OC login details as tokens will expire so it will have to periodically login to refresh it's authentication token. It needs to know the namespace where tiller is running which might not be the current project. The login you give it will need permissions to list the pods where tiller is running and to port forward to it. On minishift you can use the admin plugin and just have it use admin/admin. In a secure setup you should run this in a project seperate from both tiller and your main app with a login that can only talk to tiller and nothing else.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.7.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


begins_with_short_option()
{
	local first_option all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_oc_server=
_arg_oc_user=
_arg_oc_passwd=
_arg_tiller_namespace=
_arg_namespace=
_arg_git_url=
_arg_git_name=
_arg_webhook_ref_regex=
_arg_env=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_insecure_no_tls_verify="false"
_arg_webhook_secret=
_arg_release_hook="false"


print_help()
{
	printf '%s\n' "Welcome to the ocd-envrionment-webhook installer. It runs heml to install into the current project. It needs some OC login details as tokens will expire so it will have to periodically login to refresh it's authentication token. It needs to know the namespace where tiller is running which might not be the current project. The login you give it will need permissions to list the pods where tiller is running and to port forward to it. On minishift you can use the admin plugin and just have it use admin/admin. In a secure setup you should run this in a project seperate from both tiller and your main app with a login that can only talk to tiller and nothing else."
	printf 'Usage: %s [--insecure-no-tls-verify <arg>] [--webhook-secret <arg>] [--release-hook <arg>] [-h|--help] <oc-server> <oc-user> <oc-passwd> <tiller-namespace> <namespace> <git-url> <git-name> <webhook-ref-regex> <env>\n' "$0"
	printf '\t%s\n' "<oc-server>: mandatory server e.g. 192.168.99.100:8443"
	printf '\t%s\n' "<oc-user>: mandatory username e.g. admin"
	printf '\t%s\n' "<oc-passwd>: mandatory password e.g. admin"
	printf '\t%s\n' "<tiller-namespace>: mandatory namespace where tiller is running"
	printf '\t%s\n' "<namespace>: mandatory namespace to install into"
	printf '\t%s\n' "<git-url>: mandatory url of the enviroment code to checkout e.g. https://github.com/ocd-scm/ocd-demo-env-build.git "
	printf '\t%s\n' "<git-name>: mandatory name of the repo that fires the webhook used to sanity check the webhook payload is from the correct repo e.g. ocd-scm/ocd-demo-env-build"
	printf '\t%s\n' "<webhook-ref-regex>: mandatory the regex to match the git ref e.g. "refs/heads/master" to match a branch or ".*-RELEASE" to match a release tag"
	printf '\t%s\n' "<env>: mandatory the env prefix to make the installed chart unique e.g. live"
	printf '\t%s\n' "--insecure-no-tls-verify: optional skip TLS verify needed for minishift (default: 'false')"
	printf '\t%s\n' "--webhook-secret: optional webhook secret will otherwise be generated (no default)"
	printf '\t%s\n' "--release-hook: optional match a release event rather than a push event (default: 'false')"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--insecure-no-tls-verify)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_insecure_no_tls_verify="$2"
				shift
				;;
			--insecure-no-tls-verify=*)
				_arg_insecure_no_tls_verify="${_key##--insecure-no-tls-verify=}"
				;;
			--webhook-secret)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_webhook_secret="$2"
				shift
				;;
			--webhook-secret=*)
				_arg_webhook_secret="${_key##--webhook-secret=}"
				;;
			--release-hook)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_release_hook="$2"
				shift
				;;
			--release-hook=*)
				_arg_release_hook="${_key##--release-hook=}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'oc-server', 'oc-user', 'oc-passwd', 'tiller-namespace', 'namespace', 'git-url', 'git-name', 'webhook-ref-regex' and 'env'"
	test "${_positionals_count}" -ge 9 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 9 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 9 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 9 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_oc_server _arg_oc_user _arg_oc_passwd _arg_tiller_namespace _arg_namespace _arg_git_url _arg_git_name _arg_webhook_ref_regex _arg_env "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


source ./install.sh

# ] <-- needed because of Argbash
